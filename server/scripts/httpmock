#!/usr/bin/env node
// vim: ft=javascript
'use strict';

function usage() {
    console.log("Usage: httpmock <command> [--port <port>] [--pidfile <pidfile>]\n");
    console.log("where <command> is one of:");
    console.log("\tstart, stop, restart");
}

function error(message) {
    console.log(message + "\n");
    usage();
    process.exit(1);
}

var cli = {
    parse: function (argv, defaultOptions) {
        var parseOption = function (key, value) {
            var OPTION_PREFIX = /^--/,
                optionName;

            if (key.match(OPTION_PREFIX) === null) {
                error("Invalid option '" + key + "'.");
            }
            optionName = key.replace(OPTION_PREFIX, '');

            if (!defaultOptions.hasOwnProperty(optionName)) {
                error("Option '" + optionName + "' not recognized.");
            }
            if (value === undefined) {
                error("No argument provided for option '" + optionName + "'.");
            }

            return {
                key: optionName,
                value: value
            };
        };

        var parseOptions = function () {
            var options = {},
                option,
                key,
                i;

            // Add custom options
            for (i = 1; i < argv.length; i += 2) {
                option = parseOption(argv[i], argv[i+1]);
                options[option.key] = option.value;
            }

            // add default options
            for (key in defaultOptions) {
                if (defaultOptions.hasOwnProperty(key) && !options.hasOwnProperty(key)) {
                    options[key] = defaultOptions[key];
                }
            }

            return options;
        };

        var parseCommand = function () {
            var command = argv[0];

            if (command === undefined) {
                error("Missing command.");
            }
            return command;
        };

        return {
            command: parseCommand(),
            options: parseOptions()
        };
    }
};

var serverAt = function (options) {
    return {
        start: function () {
            var basedir = __dirname.replace(/\w+$/, '');

            // Needed to require express locally; e.g. it does a require('connect')
            ['connect/lib', 'qs', 'mime'].forEach(function (path) {
                require.paths.unshift(basedir + '/deps/' + path);
            });

            require.paths.push(basedir);
            require.paths.push(basedir + '/lib');
            require.paths.push(basedir + '/deps');

            var server = require('controlServer').create(options.port);

            require('fs').writeFileSync(options.pidfile, process.pid.toString());

            process.on('SIGTERM', function () {
                server.close();
            });
        },

        stop: function () {
            var exec = require('child_process').exec,
                kill = '[ -e PIDFILE ] && kill `cat PIDFILE`'.replace(/PIDFILE/g, options.pidfile),
                rm = '[ -e PIDFILE ] && rm PIDFILE'.replace(/PIDFILE/g, options.pidfile),
                command = kill + '; ' + rm;

            exec(command, function (error, stdout, stderr) {
                if (error !== null) {
                    console.log(stderr);
                }
            });
        },

        restart: function () {
            this.stop();
            this.start();
        }
    };
};

var defaultOptions = { port: 3000, pidfile: 'httpmock.pid' },
    commandLine = cli.parse(process.argv.slice(2), defaultOptions),
    server = serverAt(commandLine.options);

switch (commandLine.command) {
    case 'start':
        server.start();
        break;
    case 'stop':
        server.stop();
        break;
    case 'restart':
        server.restart();
        break;
    default:
        error("Invalid command '" + commandLine.command + "'.");
        break;
}
